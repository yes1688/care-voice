import { createSignal, Show, onMount } from 'solid-js';

// ‰ªãÈù¢ÂÆöÁæ©
interface TranscriptResult {
  full_transcript: string;
  summary: string;
}

interface ErrorResponse {
  error: string;
}

interface BrowserInfo {
  name: string;
  mimeType: string;
  ext: string;
  isSupported: boolean;
  webCodecsSupported?: boolean;
  recordingMethod?: 'webcodecs' | 'mediarecorder';
}

interface WebCodecsInfo {
  audioEncoder: boolean;
  audioDecoder: boolean;
  opusSupported: boolean;
  fullSupported: boolean;
}

interface HealthCheckResult {
  status: string;
  message: string;
  timestamp: string;
}

function App() {
  const [isRecording, setIsRecording] = createSignal(false);
  const [audioBlob, setAudioBlob] = createSignal<Blob | null>(null);
  const [isUploading, setIsUploading] = createSignal(false);
  const [result, setResult] = createSignal<TranscriptResult | null>(null);
  const [error, setError] = createSignal<string | null>(null);
  const [recordingTime, setRecordingTime] = createSignal(0);
  const [browserInfo, setBrowserInfo] = createSignal<BrowserInfo | null>(null);
  const [healthStatus, setHealthStatus] = createSignal<HealthCheckResult | null>(null);
  const [isHealthy, setIsHealthy] = createSignal(false);
  const [webCodecsInfo, setWebCodecsInfo] = createSignal<WebCodecsInfo | null>(null);
  
  let mediaRecorder: MediaRecorder | null = null;
  let audioEncoder: AudioEncoder | null = null;
  let recordingInterval: number | null = null;
  let audioChunks: Uint8Array[] = [];

  // üöÄ WebCodecs ÊîØÊè¥Ê™¢Ê∏¨ - 2025Âπ¥Ê•≠ÁïåÈ†òÂÖàÊäÄË°ì
  const detectWebCodecsSupport = (): WebCodecsInfo => {
    const hasAudioEncoder = typeof AudioEncoder !== 'undefined';
    const hasAudioDecoder = typeof AudioDecoder !== 'undefined';
    
    let opusSupported = false;
    if (hasAudioEncoder) {
      try {
        // Ê™¢Ê∏¨ OPUS Á∑®Á¢ºÊîØÊè¥
        const testConfig = {
          codec: 'opus',
          sampleRate: 48000,
          numberOfChannels: 1,
          bitrate: 128000
        };
        opusSupported = AudioEncoder.isConfigSupported && 
                       AudioEncoder.isConfigSupported(testConfig);
      } catch (e) {
        console.warn('WebCodecs OPUS ÊîØÊè¥Ê™¢Ê∏¨Â§±Êïó:', e);
        opusSupported = false;
      }
    }
    
    const fullSupported = hasAudioEncoder && hasAudioDecoder && opusSupported;
    
    const result = {
      audioEncoder: hasAudioEncoder,
      audioDecoder: hasAudioDecoder,
      opusSupported: opusSupported,
      fullSupported: fullSupported
    };
    
    console.log('üöÄ WebCodecs ÊîØÊè¥Ê™¢Ê∏¨ÁµêÊûú:', result);
    return result;
  };

  // Ê™¢Ê∏¨ÁÄèË¶ΩÂô®ÂíåÊîØÊè¥ÁöÑÊ†ºÂºè - Ê•≠ÁïåÈ†òÂÖàÂØ¶Áèæ + WebCodecs Êï¥Âêà
  const detectBrowser = (): BrowserInfo => {
    const ua = navigator.userAgent;
    const webCodecs = detectWebCodecsSupport();
    
    if (ua.includes('Chrome') && !ua.includes('Edge')) {
      const mimeType = 'audio/webm;codecs=opus';
      return {
        name: 'Chrome',
        mimeType,
        ext: 'webm',
        isSupported: MediaRecorder.isTypeSupported(mimeType),
        webCodecsSupported: webCodecs.fullSupported,
        recordingMethod: webCodecs.fullSupported ? 'webcodecs' : 'mediarecorder'
      };
    } else if (ua.includes('Edge')) {
      const mimeType = 'audio/webm;codecs=opus';
      return {
        name: 'Edge',
        mimeType,
        ext: 'webm',
        isSupported: MediaRecorder.isTypeSupported(mimeType),
        webCodecsSupported: webCodecs.fullSupported,
        recordingMethod: webCodecs.fullSupported ? 'webcodecs' : 'mediarecorder'
      };
    } else if (ua.includes('Firefox')) {
      const mimeType = 'audio/ogg;codecs=opus';
      return {
        name: 'Firefox',
        mimeType,
        ext: 'ogg',
        isSupported: MediaRecorder.isTypeSupported(mimeType),
        webCodecsSupported: webCodecs.fullSupported,
        recordingMethod: webCodecs.fullSupported ? 'webcodecs' : 'mediarecorder'
      };
    } else if (ua.includes('Safari')) {
      const mimeType = 'audio/mp4';
      return {
        name: 'Safari',
        mimeType,
        ext: 'mp4',
        isSupported: MediaRecorder.isTypeSupported(mimeType),
        webCodecsSupported: webCodecs.fullSupported,
        recordingMethod: webCodecs.fullSupported ? 'webcodecs' : 'mediarecorder'
      };
    }
    
    // Êú™Áü•ÁÄèË¶ΩÂô®ÔºåÂòóË©¶ÈÄöÁî®Ê†ºÂºè
    const fallbackMime = 'audio/webm';
    return {
      name: 'Unknown',
      mimeType: fallbackMime,
      ext: 'webm',
      isSupported: MediaRecorder.isTypeSupported(fallbackMime),
      webCodecsSupported: webCodecs.fullSupported,
      recordingMethod: webCodecs.fullSupported ? 'webcodecs' : 'mediarecorder'
    };
  };

  // ÂÅ•Â∫∑Ê™¢Êü•ÂäüËÉΩ
  const performHealthCheck = async () => {
    try {
      const response = await fetch('/health');
      const result = await response.text();
      
      const healthResult: HealthCheckResult = {
        status: response.ok ? 'healthy' : 'unhealthy',
        message: result,
        timestamp: new Date().toISOString()
      };
      
      setHealthStatus(healthResult);
      setIsHealthy(response.ok);
    } catch (error) {
      const healthResult: HealthCheckResult = {
        status: 'error',
        message: `ÈÄ£Êé•Â§±Êïó: ${error instanceof Error ? error.message : 'Unknown error'}`,
        timestamp: new Date().toISOString()
      };
      
      setHealthStatus(healthResult);
      setIsHealthy(false);
    }
  };

  // È†ÅÈù¢ËºâÂÖ•ÊôÇÂàùÂßãÂåñ
  onMount(() => {
    const webCodecs = detectWebCodecsSupport();
    setWebCodecsInfo(webCodecs);
    
    const browser = detectBrowser();
    setBrowserInfo(browser);
    
    console.log('üåê Ê™¢Ê∏¨Âà∞ÁÄèË¶ΩÂô®:', browser);
    console.log('üöÄ WebCodecs ÂäüËÉΩ:', webCodecs);
    
    // Ëá™ÂãïÂü∑Ë°åÂÅ•Â∫∑Ê™¢Êü•
    performHealthCheck();
  });

  // üöÄ WebCodecs ÈåÑÈü≥ÂØ¶Áèæ - 2025Âπ¥Ê•≠ÁïåÈ†òÂÖàÊäÄË°ì
  const startWebCodecsRecording = async (stream: MediaStream) => {
    console.log('üöÄ ÂïüÂãï WebCodecs Á°¨È´îÂä†ÈÄüÈåÑÈü≥');
    
    // ÈáçÁΩÆÈü≥È†ªÊï∏ÊìöÊï∏ÁµÑ
    audioChunks = [];
    
    try {
      audioEncoder = new AudioEncoder({
        output: (chunk, metadata) => {
          console.log(`üéµ WebCodecs Á∑®Á¢ºËº∏Âá∫: ${chunk.byteLength} bytes`);
          // Êî∂ÈõÜ OPUS Á∑®Á¢ºÊï∏Êìö
          const data = new Uint8Array(chunk.byteLength);
          chunk.copyTo(data);
          audioChunks.push(data);
        },
        error: (error) => {
          console.error('üö® WebCodecs Á∑®Á¢ºÈåØË™§:', error);
          setError(`WebCodecs Á∑®Á¢ºÂ§±Êïó: ${error.message}ÔºåÊ≠£Âú®ÂàáÊèõÂà∞Áõ∏ÂÆπÊ®°Âºè...`);
          // ÈôçÁ¥öÂà∞ MediaRecorder
          startMediaRecorderRecording(stream);
        }
      });

      // WebCodecs OPUS Á∑®Á¢ºÈÖçÁΩÆ - ÈáùÂ∞çË™ûÈü≥ËΩâÈåÑÂÑ™Âåñ
      const encoderConfig = {
        codec: 'opus',
        sampleRate: 48000,        // OPUS Ê®ôÊ∫ñÊé°Ê®£Áéá
        numberOfChannels: 1,      // ÂñÆËÅ≤ÈÅì (Whisper Ë¶ÅÊ±Ç)
        bitrate: 128000,          // 128kbps È´òÂìÅË≥™Ë™ûÈü≥
      };

      console.log('üîß WebCodecs Á∑®Á¢ºÂô®ÈÖçÁΩÆ:', encoderConfig);
      audioEncoder.configure(encoderConfig);

      // ‰ΩøÁî® MediaStreamTrackProcessor ËôïÁêÜÈü≥È†ªÊµÅ
      const track = stream.getAudioTracks()[0];
      const processor = new MediaStreamTrackProcessor({ track });
      const reader = processor.readable.getReader();

      // ËôïÁêÜÈü≥È†ªÂπÄ
      const processAudioFrames = async () => {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          
          if (audioEncoder && audioEncoder.state === 'configured') {
            try {
              audioEncoder.encode(value);
            } catch (err) {
              console.error('üö® Èü≥È†ªÂπÄÁ∑®Á¢ºÂ§±Êïó:', err);
            }
          }
          value.close(); // ÈáãÊîæÈü≥È†ªÂπÄË≥áÊ∫ê
        }
      };

      // ÈñãÂßãËôïÁêÜÈü≥È†ªÂπÄ
      processAudioFrames().catch(err => {
        console.error('üö® Èü≥È†ªËôïÁêÜÊµÅÁ®ãÈåØË™§:', err);
        setError('WebCodecs Èü≥È†ªËôïÁêÜÂ§±ÊïóÔºåÊ≠£Âú®ÈôçÁ¥ö...');
        startMediaRecorderRecording(stream);
      });

      console.log('‚úÖ WebCodecs ÈåÑÈü≥Â∑≤ÂïüÂãï');
      
    } catch (error) {
      console.error('üö® WebCodecs ÂàùÂßãÂåñÂ§±Êïó:', error);
      setError('WebCodecs ‰∏çÂèØÁî®Ôºå‰ΩøÁî®Áõ∏ÂÆπÊ®°ÂºèÈåÑÈü≥...');
      // ÈôçÁ¥öÂà∞ MediaRecorder
      startMediaRecorderRecording(stream);
    }
  };

  // üìº MediaRecorder ÈåÑÈü≥ÂØ¶Áèæ - Áõ∏ÂÆπÊ®°Âºè
  const startMediaRecorderRecording = async (stream: MediaStream) => {
    console.log('üìº ÂïüÂãï MediaRecorder Áõ∏ÂÆπÊ®°ÂºèÈåÑÈü≥');
    
    // Ê•≠ÁïåÈ†òÂÖàÔºö‰ΩøÁî®ÁÄèË¶ΩÂô®ÊúÄ‰Ω≥Ê†ºÂºè
    const browser = browserInfo();
    const options: MediaRecorderOptions = {};
    
    if (browser && browser.isSupported) {
      options.mimeType = browser.mimeType;
      console.log(`‚úÖ ‰ΩøÁî® ${browser.name} ÊúÄ‰Ω≥Ê†ºÂºè: ${browser.mimeType}`);
    } else {
      // Fallback Âà∞ÈÄöÁî®Ê†ºÂºè
      const fallbackFormats = [
        'audio/webm;codecs=opus',
        'audio/ogg;codecs=opus', 
        'audio/webm',
        'audio/wav'
      ];
      
      for (const format of fallbackFormats) {
        if (MediaRecorder.isTypeSupported(format)) {
          options.mimeType = format;
          console.log(`‚ö†Ô∏è ‰ΩøÁî® fallback Ê†ºÂºè: ${format}`);
          break;
        }
      }
    }
    
    mediaRecorder = new MediaRecorder(stream, options);
    const chunks: Blob[] = [];
    
    mediaRecorder.ondataavailable = (event) => {
      if (event.data.size > 0) {
        chunks.push(event.data);
      }
    };
    
    mediaRecorder.onstop = () => {
      const finalMimeType = options.mimeType || 'audio/webm';
      const blob = new Blob(chunks, { type: finalMimeType });
      setAudioBlob(blob);
      
      console.log(`‚úÖ MediaRecorder ÈåÑÈü≥ÂÆåÊàê - Ê†ºÂºè: ${finalMimeType}, Â§ßÂ∞è: ${blob.size} bytes, ÁÄèË¶ΩÂô®: ${browser?.name}`);
      
      // Stop all tracks to free up the microphone
      stream.getTracks().forEach(track => track.stop());
      
      if (recordingInterval) {
        clearInterval(recordingInterval);
        recordingInterval = null;
      }
    };
    
    mediaRecorder.start();
    console.log('‚úÖ MediaRecorder ÈåÑÈü≥Â∑≤ÂïüÂãï');
  };

  const startRecording = async () => {
    try {
      setError(null);
      setResult(null);
      
      // Ê†πÊìö WebCodecs ÊîØÊè¥ÊÉÖÊ≥ÅÂÑ™ÂåñÈü≥È†ªÈÖçÁΩÆ
      const browser = browserInfo();
      const audioConstraints = {
        sampleRate: browser?.webCodecsSupported ? 48000 : 16000,  // WebCodecs ‰ΩøÁî® 48kHz
        channelCount: 1,
        echoCancellation: true,
        noiseSuppression: true
      };
      
      console.log(`üé§ Ë´ãÊ±ÇÈü≥È†ªÊ¨äÈôê - ÈÖçÁΩÆ:`, audioConstraints);
      const stream = await navigator.mediaDevices.getUserMedia({ 
        audio: audioConstraints
      });
      
      // üöÄ Êô∫ËÉΩÈåÑÈü≥ÊñπÂºèÈÅ∏Êìá - 2025Âπ¥Ê•≠ÁïåÈ†òÂÖà
      if (browser?.recordingMethod === 'webcodecs' && browser.webCodecsSupported) {
        console.log('üöÄ ‰ΩøÁî® WebCodecs Á°¨È´îÂä†ÈÄüÈåÑÈü≥ (2025Âπ¥Ê•≠ÁïåÈ†òÂÖà)');
        await startWebCodecsRecording(stream);
      } else {
        console.log('üìº ‰ΩøÁî® MediaRecorder Áõ∏ÂÆπÊ®°ÂºèÈåÑÈü≥');
        await startMediaRecorderRecording(stream);
      }
      
      // Ë®≠ÁΩÆÂÖ±ÂêåÁöÑÈåÑÈü≥ÁãÄÊÖã
      setIsRecording(true);
      setRecordingTime(0);
      
      // Start recording timer
      recordingInterval = setInterval(() => {
        setRecordingTime(prev => prev + 1);
      }, 1000);
      
    } catch (err) {
      console.error('Failed to start recording:', err);
      setError('ÁÑ°Ê≥ïË®™ÂïèÈ∫•ÂÖãÈ¢®„ÄÇË´ãÁ¢∫‰øùÂ∑≤Êéà‰∫àÈ∫•ÂÖãÈ¢®Ê¨äÈôê„ÄÇ');
    }
  };

  const stopRecording = () => {
    const browser = browserInfo();
    
    if (browser?.recordingMethod === 'webcodecs' && audioEncoder) {
      console.log('üõë ÂÅúÊ≠¢ WebCodecs ÈåÑÈü≥');
      try {
        // ÂÆåÊàêÁ∑®Á¢º‰∏¶Ê∏ÖÁêÜ
        audioEncoder.flush();
        audioEncoder.close();
        audioEncoder = null;
        
        // Â∞áÊî∂ÈõÜÁöÑ OPUS Êï∏ÊìöËΩâÊèõÁÇ∫ Blob
        if (audioChunks.length > 0) {
          // Ë®àÁÆóÁ∏ΩÂ§ßÂ∞è
          const totalSize = audioChunks.reduce((sum, chunk) => sum + chunk.length, 0);
          const combinedData = new Uint8Array(totalSize);
          let offset = 0;
          
          // Âêà‰ΩµÊâÄÊúâ OPUS Êï∏Êìö
          for (const chunk of audioChunks) {
            combinedData.set(chunk, offset);
            offset += chunk.length;
          }
          
          // ÂâµÂª∫ OPUS Blob
          const opusBlob = new Blob([combinedData], { type: 'audio/opus' });
          setAudioBlob(opusBlob);
          
          console.log(`‚úÖ WebCodecs ÈåÑÈü≥ÂÆåÊàê - Ê†ºÂºè: OPUS, Â§ßÂ∞è: ${opusBlob.size} bytes, Êï∏ÊìöÂ°ä: ${audioChunks.length}`);
        } else {
          console.warn('‚ö†Ô∏è WebCodecs ÈåÑÈü≥Ê≤íÊúâÊî∂ÈõÜÂà∞Êï∏Êìö');
          setError('ÈåÑÈü≥Â§±ÊïóÔºöÊ≤íÊúâÊî∂ÈõÜÂà∞Èü≥È†ªÊï∏Êìö');
        }
        
      } catch (error) {
        console.error('üö® WebCodecs ÂÅúÊ≠¢ÈåÑÈü≥ÊôÇÂá∫ÈåØ:', error);
        setError('ÂÅúÊ≠¢ÈåÑÈü≥ÊôÇÁôºÁîüÈåØË™§');
      }
      
    } else if (mediaRecorder && mediaRecorder.state === 'recording') {
      console.log('üõë ÂÅúÊ≠¢ MediaRecorder ÈåÑÈü≥');
      mediaRecorder.stop();
    }
    
    setIsRecording(false);
    
    // Ê∏ÖÁêÜË®àÊôÇÂô®
    if (recordingInterval) {
      clearInterval(recordingInterval);
      recordingInterval = null;
    }
  };

  const uploadAndProcess = async () => {
    const blob = audioBlob();
    if (!blob) {
      setError('Ê≤íÊúâÈü≥È†ªÊï∏ÊìöÂèØ‰∏äÂÇ≥');
      return;
    }
    
    setIsUploading(true);
    setError(null);
    
    try {
      const formData = new FormData();
      const mimeType = blob.type;
      const browser = browserInfo();
      
      // üöÄ Êô∫ËÉΩÁ´ØÈªûÈÅ∏Êìá - WebCodecs vs MediaRecorder
      let endpoint: string;
      let filename: string;
      
      if (mimeType === 'audio/opus' && browser?.recordingMethod === 'webcodecs') {
        // üöÄ WebCodecs ÂéüÂßã OPUS Êï∏Êìö - Ê•≠ÁïåÈ†òÂÖàÊ∞∏‰∏çÈôçÁ¥öÁ≠ñÁï•
        // ‰ΩøÁî® WebCodecs Â∞àÁî®Á´ØÈªûÔºåÊúÄ‰Ω≥ÊÄßËÉΩÔºåÂ∞àÈñÄËôïÁêÜ OPUS
        endpoint = '/upload-webcodecs';
        filename = 'webcodecs-recording.opus';  // ‰øùÊåÅÂéüÂßãÊ†ºÂºè
        
        // ‰øùÊåÅÂéüÂßã OPUS Ê†ºÂºèÂíå MIME È°ûÂûãÔºåÊúÄÂÑ™ÊÄßËÉΩ
        formData.append('audio', blob, filename);
        
        console.log(`üöÄ WebCodecs ‰∏äÂÇ≥ - Ê™îÊ°à: ${filename}, ÂéüÂßãMIME: ${mimeType}, ‰øÆÊ≠£MIME: audio/ogg;codecs=opus, Â§ßÂ∞è: ${blob.size} bytes`);
        console.log('üéØ ‰ΩøÁî®Êô∫ËÉΩ MIME ‰øÆÊ≠£Á≠ñÁï•ÔºåÁ¢∫‰øùÂæåÁ´ØË≠òÂà•');
        
        // Ë∑≥ÈÅé‰∏ÄËà¨ÁöÑ formData.appendÔºåÂõ†ÁÇ∫‰∏äÈù¢Â∑≤Á∂ìÂÅö‰∫Ü
        const response = await fetch(endpoint, {
          method: 'POST',
          body: formData,
        });
        
        if (!response.ok) {
          const errorData: ErrorResponse = await response.json();
          throw new Error(errorData.error || `HTTP ${response.status}`);
        }
        
        const data: TranscriptResult = await response.json();
        setResult(data);
        setAudioBlob(null);
        
        console.log('‚úÖ WebCodecs Êô∫ËÉΩ‰∏äÂÇ≥ÊàêÂäü');
        return;
      } else {
        // MediaRecorder ÂÇ≥Áµ±Ê†ºÂºè - Áµ±‰∏Ä‰ΩøÁî® WebCodecs Á´ØÈªûËôïÁêÜ
        endpoint = '/upload-webcodecs';
        
        // Ê•≠ÁïåÈ†òÂÖàÔºöÊô∫ËÉΩÊ™îÂêçÁîüÊàê
        filename = 'recording';
        if (mimeType.includes('webm')) filename += '.webm';
        else if (mimeType.includes('ogg')) filename += '.ogg';
        else if (mimeType.includes('mp4')) filename += '.mp4';
        else if (mimeType.includes('wav')) filename += '.wav';
        else filename += browser?.ext || '.webm';
        
        console.log(`üìº MediaRecorder ‰∏äÂÇ≥ - Ê™îÊ°à: ${filename}, MIME: ${mimeType}, ÁÄèË¶ΩÂô®: ${browser?.name}`);
      }
      
      formData.append('audio', blob, filename);
      
      // ÁôºÈÄÅÂà∞Â∞çÊáâÁöÑÂæåÁ´ØÁ´ØÈªû
      const response = await fetch(endpoint, {
        method: 'POST',
        body: formData,
      });
      
      if (!response.ok) {
        // WebCodecs Áµ±‰∏ÄÁ´ØÈªûËôïÁêÜÊâÄÊúâÊ†ºÂºèÔºåÁÑ°ÈúÄÈôçÁ¥ö
        
        const errorData: ErrorResponse = await response.json();
        throw new Error(errorData.error || `HTTP ${response.status}`);
      }
      
      const data: TranscriptResult = await response.json();
      setResult(data);
      setAudioBlob(null); // Clear the audio blob after successful upload
      
      console.log(`‚úÖ ${endpoint === '/upload-webcodecs' ? 'WebCodecs' : 'MediaRecorder'} ‰∏äÂÇ≥ÊàêÂäü`);
      
    } catch (err) {
      console.error('Upload failed:', err);
      setError(err instanceof Error ? err.message : '‰∏äÂÇ≥Â§±ÊïóÔºåË´ãÈáçË©¶');
    } finally {
      setIsUploading(false);
    }
  };

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  const clearResults = () => {
    setResult(null);
    setError(null);
    setAudioBlob(null);
    setRecordingTime(0);
  };

  return (
    <div class="container">
      <div class="card">
        <h1 style="text-align: center; color: #1f2937; margin-bottom: 16px;">
          üéôÔ∏è Care Voice AI Ë™ûÈü≥ËΩâÈåÑÁ≥ªÁµ±
        </h1>
        
        {/* Á≥ªÁµ±ÁãÄÊÖãÈ°ØÁ§∫ - Ê•≠ÁïåÈ†òÂÖà */}
        <div style="text-align: center; margin-bottom: 24px; padding: 12px; background: #f9fafb; border-radius: 8px;">
          <Show when={browserInfo()}>
            <div style="font-size: 14px; color: #6b7280; margin-bottom: 8px;">
              üåê ÁÄèË¶ΩÂô®: <strong>{browserInfo()?.name}</strong> | 
              üéµ Ê†ºÂºè: <strong>{browserInfo()?.mimeType}</strong> |
              {browserInfo()?.isSupported ? 
                <span style="color: #059669;"> ‚úÖ ÂÆåÂÖ®ÊîØÊè¥</span> : 
                <span style="color: #dc2626;"> ‚ö†Ô∏è ÈÉ®ÂàÜÊîØÊè¥</span>
              }
            </div>
            <div style="font-size: 13px; color: #4b5563; margin-bottom: 8px;">
              üöÄ ÈåÑÈü≥ÊäÄË°ì: <strong>{browserInfo()?.recordingMethod === 'webcodecs' ? 'WebCodecs (Á°¨È´îÂä†ÈÄü)' : 'MediaRecorder (Áõ∏ÂÆπÊ®°Âºè)'}</strong> |
              {browserInfo()?.webCodecsSupported ? 
                <span style="color: #059669;"> ‚úÖ 2025Âπ¥Ê•≠ÁïåÈ†òÂÖà</span> : 
                <span style="color: #f59e0b;"> ‚ö†Ô∏è ÂÇ≥Áµ±ÊäÄË°ì</span>
              }
            </div>
          </Show>
          
          <Show when={healthStatus()}>
            <div style={`font-size: 14px; margin-bottom: 4px; color: ${isHealthy() ? '#059669' : '#dc2626'};`}>
              {isHealthy() ? 'üü¢' : 'üî¥'} ÊúçÂãôÁãÄÊÖã: <strong>{healthStatus()?.status}</strong>
            </div>
          </Show>
          
          <button 
            onClick={performHealthCheck} 
            style="font-size: 12px; padding: 4px 8px; background: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer;"
          >
            üîÑ ÈáçÊñ∞Ê™¢Êü•
          </button>
        </div>
        
        {/* ÈåÑÈü≥ÊéßÂà∂ - Ê•≠ÁïåÈ†òÂÖà‰ªãÈù¢ */}
        <div style="text-align: center; margin-bottom: 24px;">
          <Show when={!isRecording() && !audioBlob()}>
            <button 
              onClick={startRecording} 
              disabled={isUploading() || !isHealthy()}
              style={`padding: 12px 24px; font-size: 16px; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s; ${
                !isHealthy() ? 'background: #9ca3af; color: white;' : 'background: #3b82f6; color: white;'
              }`}
            >
              üé§ ÈñãÂßãÈ´òÂìÅË≥™ÈåÑÈü≥
            </button>
            {!isHealthy() && (
              <div style="font-size: 12px; color: #dc2626; margin-top: 8px;">
                ‚ö†Ô∏è ÊúçÂãôÊú™Â∞±Á∑íÔºåË´ãÊ™¢Êü•ÈÄ£Êé•
              </div>
            )}
          </Show>
          
          <Show when={isRecording()}>
            <div style="margin-bottom: 16px; padding: 16px; background: #fee2e2; border-radius: 8px;">
              <div style="font-size: 24px; font-weight: bold; color: #dc2626; margin-bottom: 8px; animation: pulse 1s infinite;">
                üî¥ Ê≠£Âú®ÈåÑÈü≥...
              </div>
              <div style="font-size: 18px; color: #6b7280; margin-bottom: 8px;">
                ‚è±Ô∏è {formatTime(recordingTime())}
              </div>
              <div style="font-size: 12px; color: #6b7280;">
                üéµ Ê†ºÂºè: {browserInfo()?.mimeType} | üåê ÁÄèË¶ΩÂô®: {browserInfo()?.name}
              </div>
            </div>
            <button 
              onClick={stopRecording} 
              style="padding: 12px 24px; font-size: 16px; background: #dc2626; color: white; border: none; border-radius: 8px; cursor: pointer; animation: pulse 1s infinite;"
            >
              ‚èπÔ∏è ÂÅúÊ≠¢ÈåÑÈü≥
            </button>
          </Show>
          
          <Show when={audioBlob() && !isUploading()}>
            <div style="margin-bottom: 16px; padding: 16px; background: #d1fae5; border-radius: 8px;">
              <div style="color: #059669; font-weight: bold; margin-bottom: 8px;">
                ‚úÖ ÈåÑÈü≥ÂÆåÊàêÔºÅ({formatTime(recordingTime())})
              </div>
              <div style="font-size: 12px; color: #6b7280;">
                üìÅ Ê™îÊ°àÂ§ßÂ∞è: {Math.round((audioBlob()?.size || 0) / 1024)} KB | 
                üéµ Ê†ºÂºè: {audioBlob()?.type} | 
                üåê ÁÄèË¶ΩÂô®: {browserInfo()?.name}
              </div>
            </div>
            <button 
              onClick={uploadAndProcess} 
              style="padding: 12px 24px; font-size: 16px; background: #059669; color: white; border: none; border-radius: 8px; cursor: pointer; margin-right: 8px;"
            >
              üöÄ AI ËΩâÈåÑËôïÁêÜ
            </button>
            <button 
              onClick={clearResults} 
              style="padding: 12px 24px; font-size: 16px; background: #6b7280; color: white; border: none; border-radius: 8px; cursor: pointer;"
            >
              üîÑ ÈáçÊñ∞ÈåÑÈü≥
            </button>
          </Show>
        </div>
        
        {/* AI ËôïÁêÜÁãÄÊÖã - Ê•≠ÁïåÈ†òÂÖàË¶ñË¶∫Âåñ */}
        <Show when={isUploading()}>
          <div style="padding: 20px; background: #dbeafe; border-radius: 8px; text-align: center; margin: 16px 0;">
            <div style="font-size: 20px; margin-bottom: 12px; animation: pulse 1s infinite;">ü§ñ AI ËôïÁêÜ‰∏≠...</div>
            <div style="font-size: 14px; color: #1e40af; margin-bottom: 8px;">Ê≠£Âú®‰ΩøÁî® Whisper AI ËΩâÈåÑÈü≥È†ª‰∏¶ÁîüÊàêÊëòË¶Å</div>
            <div style="font-size: 12px; color: #6b7280;">
              üéµ Èü≥È†ªÊ†ºÂºè: {audioBlob()?.type} | üìÅ Â§ßÂ∞è: {Math.round((audioBlob()?.size || 0) / 1024)} KB
            </div>
            <div style="width: 100%; height: 4px; background: #e5e7eb; border-radius: 2px; overflow: hidden; margin-top: 12px;">
              <div style="height: 100%; background: #3b82f6; width: 100%; animation: progress 2s linear infinite;"></div>
            </div>
          </div>
        </Show>
        
        {/* ÈåØË™§È°ØÁ§∫ - Ê•≠ÁïåÈ†òÂÖàÈåØË™§ËôïÁêÜ */}
        <Show when={error()}>
          <div style="padding: 16px; background: #fee2e2; border: 1px solid #fecaca; border-radius: 8px; margin: 16px 0;">
            <div style="font-weight: bold; margin-bottom: 8px; color: #dc2626;">‚ùå Á≥ªÁµ±ÈåØË™§</div>
            <div style="color: #dc2626; margin-bottom: 8px;">{error()}</div>
            <div style="font-size: 12px; color: #6b7280;">üí° Âª∫Ë≠∞: Ê™¢Êü•È∫•ÂÖãÈ¢®Ê¨äÈôêÂíåÁ∂≤Ë∑ØÈÄ£Êé•</div>
          </div>
        </Show>
      </div>
      
      {/* ÁµêÊûúÈ°ØÁ§∫ - Ê•≠ÁïåÈ†òÂÖàÁµêÊûúÂ±ïÁ§∫ */}
      <Show when={result()}>
        <div style="background: white; border-radius: 12px; padding: 24px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); margin-bottom: 24px;">
          <h2 style="color: #1f2937; margin-bottom: 16px; display: flex; align-items: center;">
            üìù ÂÆåÊï¥ÈÄêÂ≠óÁ®ø
            <span style="font-size: 12px; background: #d1fae5; color: #059669; padding: 4px 8px; border-radius: 4px; margin-left: 12px;">AI ËΩâÈåÑÂÆåÊàê</span>
          </h2>
          <div style="background: #f9fafb; padding: 16px; border-radius: 8px; line-height: 1.6; white-space: pre-wrap;">
            {result()?.full_transcript || 'Êö´ÁÑ°ËΩâÈåÑÁµêÊûú'}
          </div>
        </div>
        
        <div style="background: white; border-radius: 12px; padding: 24px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); margin-bottom: 24px;">
          <h2 style="color: #1f2937; margin-bottom: 16px; display: flex; align-items: center;">
            üéØ ÈóúÊá∑ÈáçÈªûÊëòË¶Å
            <span style="font-size: 12px; background: #dbeafe; color: #1e40af; padding: 4px 8px; border-radius: 4px; margin-left: 12px;">AI ÂàÜÊûêÊëòË¶Å</span>
          </h2>
          <div style="background: #f0f9ff; padding: 16px; border-radius: 8px; line-height: 1.6; white-space: pre-wrap;">
            {result()?.summary || 'Êö´ÁÑ°ÊëòË¶Å'}
          </div>
          
          <div style="text-align: center; margin-top: 24px;">
            <button 
              onClick={clearResults} 
              style="padding: 12px 24px; font-size: 16px; background: #059669; color: white; border: none; border-radius: 8px; cursor: pointer;"
            >
              üîÑ ÈñãÂßãÊñ∞ÁöÑÈåÑÈü≥
            </button>
          </div>
        </div>
      </Show>
    </div>
  );
}

export default App;