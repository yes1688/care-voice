import { createSignal, Show, onMount } from 'solid-js';

// ‰ªãÈù¢ÂÆöÁæ©
interface TranscriptResult {
  full_transcript: string;
  summary: string;
}

interface ErrorResponse {
  error: string;
}

interface BrowserInfo {
  name: string;
  mimeType: string;
  ext: string;
  isSupported: boolean;
  webCodecsSupported?: boolean;
  recordingMethod?: 'webcodecs' | 'mediarecorder';
}

interface WebCodecsInfo {
  audioEncoder: boolean;
  audioDecoder: boolean;
  opusSupported: boolean;
  fullSupported: boolean;
}

interface HealthCheckResult {
  status: string;
  message: string;
  timestamp: string;
}

function App() {
  const [isRecording, setIsRecording] = createSignal(false);
  const [audioBlob, setAudioBlob] = createSignal<Blob | null>(null);
  const [isUploading, setIsUploading] = createSignal(false);
  const [result, setResult] = createSignal<TranscriptResult | null>(null);
  const [error, setError] = createSignal<string | null>(null);
  const [recordingTime, setRecordingTime] = createSignal(0);
  const [browserInfo, setBrowserInfo] = createSignal<BrowserInfo | null>(null);
  const [healthStatus, setHealthStatus] = createSignal<HealthCheckResult | null>(null);
  const [isHealthy, setIsHealthy] = createSignal(false);
  const [webCodecsInfo, setWebCodecsInfo] = createSignal<WebCodecsInfo | null>(null);
  
  let mediaRecorder: MediaRecorder | null = null;
  let audioEncoder: AudioEncoder | null = null;
  let recordingInterval: number | null = null;
  let audioPackets: Uint8Array[] = []; // üéØ ‰øÆÂæ©ÔºöÊîπÁî®Áç®Á´ãÂåÖÊî∂ÈõÜ

  // üöÄ WebCodecs ÊîØÊè¥Ê™¢Ê∏¨ - 2025Âπ¥Ê•≠ÁïåÈ†òÂÖàÊäÄË°ì
  const detectWebCodecsSupport = (): WebCodecsInfo => {
    const hasAudioEncoder = typeof AudioEncoder !== 'undefined';
    const hasAudioDecoder = typeof AudioDecoder !== 'undefined';
    
    let opusSupported = false;
    if (hasAudioEncoder) {
      try {
        // Ê™¢Ê∏¨ OPUS Á∑®Á¢ºÊîØÊè¥ - ‰ΩøÁî®ÂØ¶ÈöõÈÖçÁΩÆÂèÉÊï∏
        const testConfig = {
          codec: 'opus',
          sampleRate: 48000,      // üéØ ‰øÆÂæ©: ‰ΩøÁî®ÂØ¶Èöõ48kHzÈÖçÁΩÆ
          numberOfChannels: 1,
          bitrate: 128000         // üéØ ‰øÆÂæ©: ‰ΩøÁî®ÂØ¶Èöõ128kbpsÈÖçÁΩÆ
        };
        opusSupported = AudioEncoder.isConfigSupported && 
                       AudioEncoder.isConfigSupported(testConfig);
      } catch (e) {
        console.warn('WebCodecs OPUS ÊîØÊè¥Ê™¢Ê∏¨Â§±Êïó:', e);
        opusSupported = false;
      }
    }
    
    const fullSupported = hasAudioEncoder && hasAudioDecoder && opusSupported;
    
    const result = {
      audioEncoder: hasAudioEncoder,
      audioDecoder: hasAudioDecoder,
      opusSupported: opusSupported,
      fullSupported: fullSupported
    };
    
    console.log('üöÄ WebCodecs ÊîØÊè¥Ê™¢Ê∏¨ÁµêÊûú:', result);
    return result;
  };

  // Ê™¢Ê∏¨ÁÄèË¶ΩÂô®ÂíåÊîØÊè¥ÁöÑÊ†ºÂºè - Ê•≠ÁïåÈ†òÂÖàÂØ¶Áèæ + WebCodecs Êï¥Âêà
  const detectBrowser = (): BrowserInfo => {
    const ua = navigator.userAgent;
    const webCodecs = detectWebCodecsSupport();
    
    if (ua.includes('Chrome') && !ua.includes('Edge')) {
      const mimeType = 'audio/webm;codecs=opus';
      return {
        name: 'Chrome',
        mimeType,
        ext: 'webm',
        isSupported: MediaRecorder.isTypeSupported(mimeType),
        webCodecsSupported: webCodecs.fullSupported,
        recordingMethod: webCodecs.fullSupported ? 'webcodecs' : 'mediarecorder'
      };
    } else if (ua.includes('Edge')) {
      const mimeType = 'audio/webm;codecs=opus';
      return {
        name: 'Edge',
        mimeType,
        ext: 'webm',
        isSupported: MediaRecorder.isTypeSupported(mimeType),
        webCodecsSupported: webCodecs.fullSupported,
        recordingMethod: webCodecs.fullSupported ? 'webcodecs' : 'mediarecorder'
      };
    } else if (ua.includes('Firefox')) {
      const mimeType = 'audio/ogg;codecs=opus';
      return {
        name: 'Firefox',
        mimeType,
        ext: 'ogg',
        isSupported: MediaRecorder.isTypeSupported(mimeType),
        webCodecsSupported: webCodecs.fullSupported,
        recordingMethod: webCodecs.fullSupported ? 'webcodecs' : 'mediarecorder'
      };
    } else if (ua.includes('Safari')) {
      const mimeType = 'audio/mp4';
      return {
        name: 'Safari',
        mimeType,
        ext: 'mp4',
        isSupported: MediaRecorder.isTypeSupported(mimeType),
        webCodecsSupported: webCodecs.fullSupported,
        recordingMethod: webCodecs.fullSupported ? 'webcodecs' : 'mediarecorder'
      };
    }
    
    // Êú™Áü•ÁÄèË¶ΩÂô®ÔºåÂòóË©¶ÈÄöÁî®Ê†ºÂºè
    const fallbackMime = 'audio/webm';
    return {
      name: 'Unknown',
      mimeType: fallbackMime,
      ext: 'webm',
      isSupported: MediaRecorder.isTypeSupported(fallbackMime),
      webCodecsSupported: webCodecs.fullSupported,
      recordingMethod: webCodecs.fullSupported ? 'webcodecs' : 'mediarecorder'
    };
  };

  // ÂÅ•Â∫∑Ê™¢Êü•ÂäüËÉΩ
  const performHealthCheck = async () => {
    try {
      const response = await fetch('/health');
      const result = await response.text();
      
      const healthResult: HealthCheckResult = {
        status: response.ok ? 'healthy' : 'unhealthy',
        message: result,
        timestamp: new Date().toISOString()
      };
      
      setHealthStatus(healthResult);
      setIsHealthy(response.ok);
    } catch (error) {
      const healthResult: HealthCheckResult = {
        status: 'error',
        message: `ÈÄ£Êé•Â§±Êïó: ${error instanceof Error ? error.message : 'Unknown error'}`,
        timestamp: new Date().toISOString()
      };
      
      setHealthStatus(healthResult);
      setIsHealthy(false);
    }
  };

  // È†ÅÈù¢ËºâÂÖ•ÊôÇÂàùÂßãÂåñ
  onMount(() => {
    const webCodecs = detectWebCodecsSupport();
    setWebCodecsInfo(webCodecs);
    
    const browser = detectBrowser();
    setBrowserInfo(browser);
    
    console.log('üåê Ê™¢Ê∏¨Âà∞ÁÄèË¶ΩÂô®:', browser);
    console.log('üöÄ WebCodecs ÂäüËÉΩ:', webCodecs);
    
    // Ëá™ÂãïÂü∑Ë°åÂÅ•Â∫∑Ê™¢Êü•
    performHealthCheck();
  });

  // üöÄ WebCodecs ÈåÑÈü≥ÂØ¶Áèæ - 2025Âπ¥Ê•≠ÁïåÈ†òÂÖàÊäÄË°ìÔºà‰øÆÂæ©ÁâàÔºâ
  const startWebCodecsRecording = async (stream: MediaStream) => {
    console.log('üöÄ ÂïüÂãï WebCodecs Á°¨È´îÂä†ÈÄüÈåÑÈü≥Ôºà‰øÆÂæ©ÁâàÔºâ');
    
    // üéØ ‰øÆÂæ©ÔºöÈáçÁΩÆÁç®Á´ãÂåÖÊï∏ÁµÑ
    audioPackets = [];
    
    try {
      audioEncoder = new AudioEncoder({
        output: (chunk, metadata) => {
          console.log(`üéµ WebCodecs Áç®Á´ãÂåÖËº∏Âá∫: ${chunk.byteLength} bytes`);
          // üéØ ÈóúÈçµ‰øÆÂæ©ÔºöÊØèÂÄã chunk Â∑≤Á∂ìÊòØÂÆåÊï¥ÁöÑ OPUS ÂåÖ
          const packetData = new Uint8Array(chunk.byteLength);
          chunk.copyTo(packetData);
          audioPackets.push(packetData); // Áõ¥Êé•Ê∑ªÂä†ÂÆåÊï¥ÂåÖÔºå‰∏çÂêà‰Ωµ
          console.log(`üì¶ Êî∂ÈõÜÂà∞ OPUS ÂåÖ ${audioPackets.length}: ${packetData.length} bytes`);
        },
        error: (error) => {
          console.error('üö® WebCodecs Á∑®Á¢ºÈåØË™§:', error);
          setError(`WebCodecs Á∑®Á¢ºÂ§±Êïó: ${error.message}`);
          // üéØ Ë®∫Êñ∑Ê®°ÂºèÔºö‰∏çÈôçÁ¥öÔºåÁõ¥Êé•È°ØÁ§∫ÈåØË™§‰ª•‰æøÂàÜÊûê
        }
      });

      // üéØ ÂÑ™ÂåñÈÖçÁΩÆÔºöÂπ≥Ë°°ÂìÅË≥™ËàáËôïÁêÜÊïàÁéá
      const optimizedEncoderConfig = {
        codec: 'opus',
        sampleRate: 48000,        // Âõ∫ÂÆö48kHzÔºàÁÄèË¶ΩÂô®Ê®ôÊ∫ñÔºâ
        numberOfChannels: 1,      // ÂñÆËÅ≤ÈÅìÔºàWhisperË¶ÅÊ±ÇÔºâ
        bitrate: 96000,           // üîß ÂÑ™ÂåñÔºö96kbpsÂπ≥Ë°°ÂìÅË≥™ËàáÊ™îÊ°àÂ§ßÂ∞è
      };

      console.log('üîß WebCodecs ÂÑ™ÂåñÁ∑®Á¢ºÂô®ÈÖçÁΩÆ:', optimizedEncoderConfig);
      
      // Á´ãÂç≥ÈÖçÁΩÆÁ∑®Á¢ºÂô®
      try {
        audioEncoder.configure(optimizedEncoderConfig);
        console.log('‚úÖ Á∑®Á¢ºÂô®ÂàùÂßãÂåñÈÖçÁΩÆÊàêÂäü');
      } catch (configError) {
        console.error('üö® Á∑®Á¢ºÂô®ÂàùÂßãÈÖçÁΩÆÂ§±Êïó:', configError);
        setError(`WebCodecs Á∑®Á¢ºÂô®ÈÖçÁΩÆÂ§±Êïó: ${configError.message}`);
        return;
      }

      // ‰ΩøÁî® MediaStreamTrackProcessor ËôïÁêÜÈü≥È†ªÊµÅ
      const track = stream.getAudioTracks()[0];
      const processor = new MediaStreamTrackProcessor({ track });
      const reader = processor.readable.getReader();

      // ËôïÁêÜÈü≥È†ªÂπÄ - Á∞°ÂåñÁâàÊú¨
      const processAudioFrames = async () => {
        let frameCount = 0;
        
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          
          // üîç È¶ñÂπÄË®∫Êñ∑ÔºàÁ∞°ÂåñÁâàÔºâ
          if (frameCount === 0) {
            console.log('üéµ AudioFrame Ê†ºÂºèÁ¢∫Ë™ç:');
            console.log(`  - ËÅ≤ÈÅìÊï∏: ${value.numberOfChannels}`);
            console.log(`  - Êé°Ê®£Áéá: ${value.sampleRate}Hz`);
            console.log(`  - ÊåÅÁ∫åÊôÇÈñì: ${value.duration}Œºs`);
            console.log('üìä ‰ΩøÁî®Âõ∫ÂÆö48kHzÈÖçÁΩÆÈÄ≤Ë°åOPUSÁ∑®Á¢º');
          }
          frameCount++;
          
          // Áõ¥Êé•Á∑®Á¢ºÔºàÁ∑®Á¢ºÂô®Â∑≤Âú®ÂàùÂßãÂåñÊôÇÈÖçÁΩÆÔºâ
          if (audioEncoder && audioEncoder.state === 'configured') {
            try {
              audioEncoder.encode(value);
            } catch (err) {
              console.error('üö® Èü≥È†ªÂπÄÁ∑®Á¢ºÂ§±Êïó:', err);
            }
          }
          value.close(); // ÈáãÊîæÈü≥È†ªÂπÄË≥áÊ∫ê
        }
        console.log(`üìä Á∏ΩÂÖ±ËôïÁêÜ‰∫Ü ${frameCount} ÂÄã AudioFrame`);
      };

      // ÈñãÂßãËôïÁêÜÈü≥È†ªÂπÄ
      processAudioFrames().catch(err => {
        console.error('üö® Èü≥È†ªËôïÁêÜÊµÅÁ®ãÈåØË™§:', err);
        setError(`WebCodecs Èü≥È†ªËôïÁêÜÂ§±Êïó: ${err.message}`);
        // üéØ Ë®∫Êñ∑Ê®°ÂºèÔºö‰∏çÈôçÁ¥öÔºå‰øùÊåÅÈåØË™§ÁãÄÊÖã‰ª•‰æøÂàÜÊûê
      });

      console.log('‚úÖ WebCodecs ÈåÑÈü≥Â∑≤ÂïüÂãï');
      
    } catch (error) {
      console.error('üö® WebCodecs ÂàùÂßãÂåñÂ§±Êïó:', error);
      setError(`WebCodecs ÂàùÂßãÂåñÂ§±Êïó: ${error.message}`);
      // üéØ Ë®∫Êñ∑Ê®°ÂºèÔºö‰∏çÈôçÁ¥öÔºåÁõ¥Êé•Â†±ÈåØ‰ª•‰æøÂàÜÊûêÂïèÈ°å
    }
  };

  // üìº MediaRecorder ÈåÑÈü≥ÂØ¶Áèæ - Áõ∏ÂÆπÊ®°Âºè
  const startMediaRecorderRecording = async (stream: MediaStream) => {
    console.log('üìº ÂïüÂãï MediaRecorder Áõ∏ÂÆπÊ®°ÂºèÈåÑÈü≥');
    
    // Ê•≠ÁïåÈ†òÂÖàÔºö‰ΩøÁî®ÁÄèË¶ΩÂô®ÊúÄ‰Ω≥Ê†ºÂºè
    const browser = browserInfo();
    const options: MediaRecorderOptions = {};
    
    if (browser && browser.isSupported) {
      options.mimeType = browser.mimeType;
      console.log(`‚úÖ ‰ΩøÁî® ${browser.name} ÊúÄ‰Ω≥Ê†ºÂºè: ${browser.mimeType}`);
    } else {
      // Fallback Âà∞ÈÄöÁî®Ê†ºÂºè
      const fallbackFormats = [
        'audio/webm;codecs=opus',
        'audio/ogg;codecs=opus', 
        'audio/webm',
        'audio/wav'
      ];
      
      for (const format of fallbackFormats) {
        if (MediaRecorder.isTypeSupported(format)) {
          options.mimeType = format;
          console.log(`‚ö†Ô∏è ‰ΩøÁî® fallback Ê†ºÂºè: ${format}`);
          break;
        }
      }
    }
    
    mediaRecorder = new MediaRecorder(stream, options);
    const chunks: Blob[] = [];
    
    mediaRecorder.ondataavailable = (event) => {
      if (event.data.size > 0) {
        chunks.push(event.data);
      }
    };
    
    mediaRecorder.onstop = () => {
      const finalMimeType = options.mimeType || 'audio/webm';
      const blob = new Blob(chunks, { type: finalMimeType });
      setAudioBlob(blob);
      
      console.log(`‚úÖ MediaRecorder ÈåÑÈü≥ÂÆåÊàê - Ê†ºÂºè: ${finalMimeType}, Â§ßÂ∞è: ${blob.size} bytes, ÁÄèË¶ΩÂô®: ${browser?.name}`);
      
      // Stop all tracks to free up the microphone
      stream.getTracks().forEach(track => track.stop());
      
      if (recordingInterval) {
        clearInterval(recordingInterval);
        recordingInterval = null;
      }
    };
    
    mediaRecorder.start();
    console.log('‚úÖ MediaRecorder ÈåÑÈü≥Â∑≤ÂïüÂãï');
  };

  const startRecording = async () => {
    try {
      setError(null);
      setResult(null);
      
      // üîß ‰øÆÂæ©Èü≥È†ªÈÖçÁΩÆ‰∏ÄËá¥ÊÄß - Áµ±‰∏Ä‰ΩøÁî®48kHzÈÅøÂÖçÁÄèË¶ΩÂô®ÈáçÊé°Ê®£
      const browser = browserInfo();
      const audioConstraints = {
        sampleRate: 48000,        // üéØ ‰øÆÂæ©: Áµ±‰∏Ä‰ΩøÁî®48kHz (ËàáWebCodecsÁ∑®Á¢ºÂô®‰∏ÄËá¥)
        channelCount: 1,          // ÂñÆËÅ≤ÈÅì
        echoCancellation: true,
        noiseSuppression: true
      };
      
      console.log(`üé§ Ë´ãÊ±ÇÈü≥È†ªÊ¨äÈôê - ÈÖçÁΩÆ:`, audioConstraints);
      const stream = await navigator.mediaDevices.getUserMedia({ 
        audio: audioConstraints
      });
      
      // üîç Ë®∫Êñ∑: Ê™¢Êü•ÁÄèË¶ΩÂô®ÂØ¶ÈöõÊèê‰æõÁöÑÈü≥È†ªÈÖçÁΩÆ
      const audioTrack = stream.getAudioTracks()[0];
      if (audioTrack) {
        const trackSettings = audioTrack.getSettings();
        console.log(`üîç ÁÄèË¶ΩÂô®ÂØ¶ÈöõÈü≥È†ªÈÖçÁΩÆ:`, trackSettings);
        console.log(`  - ÂØ¶ÈöõÊé°Ê®£Áéá: ${trackSettings.sampleRate}Hz`);
        console.log(`  - ÂØ¶ÈöõËÅ≤ÈÅìÊï∏: ${trackSettings.channelCount}`);
        console.log(`  - ÈÖçÁΩÆÂåπÈÖç: ${trackSettings.sampleRate === 48000 ? '‚úÖ ‰∏ÄËá¥' : '‚ö†Ô∏è ‰∏çÂåπÈÖç'}`);
      }
      
      // üöÄ Êô∫ËÉΩÈåÑÈü≥ÊñπÂºèÈÅ∏Êìá - 2025Âπ¥Ê•≠ÁïåÈ†òÂÖà
      if (browser?.recordingMethod === 'webcodecs' && browser.webCodecsSupported) {
        console.log('üöÄ ‰ΩøÁî® WebCodecs Á°¨È´îÂä†ÈÄüÈåÑÈü≥ (2025Âπ¥Ê•≠ÁïåÈ†òÂÖà)');
        await startWebCodecsRecording(stream);
      } else {
        console.log('üìº ‰ΩøÁî® MediaRecorder Áõ∏ÂÆπÊ®°ÂºèÈåÑÈü≥');
        await startMediaRecorderRecording(stream);
      }
      
      // Ë®≠ÁΩÆÂÖ±ÂêåÁöÑÈåÑÈü≥ÁãÄÊÖã
      setIsRecording(true);
      setRecordingTime(0);
      
      // Start recording timer
      recordingInterval = setInterval(() => {
        setRecordingTime(prev => prev + 1);
      }, 1000);
      
    } catch (err) {
      console.error('Failed to start recording:', err);
      setError('ÁÑ°Ê≥ïË®™ÂïèÈ∫•ÂÖãÈ¢®„ÄÇË´ãÁ¢∫‰øùÂ∑≤Êéà‰∫àÈ∫•ÂÖãÈ¢®Ê¨äÈôê„ÄÇ');
    }
  };

  const stopRecording = () => {
    const browser = browserInfo();
    
    if (browser?.recordingMethod === 'webcodecs' && audioEncoder) {
      console.log('üõë ÂÅúÊ≠¢ WebCodecs ÈåÑÈü≥');
      try {
        // ÂÆåÊàêÁ∑®Á¢º‰∏¶Ê∏ÖÁêÜ
        audioEncoder.flush();
        audioEncoder.close();
        audioEncoder = null;
        
        // üéØ ‰øÆÂæ©ÔºöÂ∞áÁç®Á´ãÂåÖËΩâÊèõÁÇ∫ JSON Ê†ºÂºè‰∏äÂÇ≥
        if (audioPackets.length > 0) {
          // ÂâµÂª∫ÂåÖÂê´Áç®Á´ãÂåÖÁöÑÊï∏ÊìöÁµêÊßã
          const packetsData = {
            format: 'webcodecs_opus_packets',
            packet_count: audioPackets.length,
            packets: audioPackets.map(packet => Array.from(packet)) // ËΩâÊèõÁÇ∫Êï∏Â≠óÈô£Âàó‰ª•‰æø JSON Â∫èÂàóÂåñ
          };
          
          // ÂâµÂª∫ JSON Blob
          const jsonBlob = new Blob([JSON.stringify(packetsData)], { type: 'application/json' });
          setAudioBlob(jsonBlob);
          
          console.log(`‚úÖ WebCodecs ÈåÑÈü≥ÂÆåÊàê - Ê†ºÂºè: Áç®Á´ãÂåÖÊ®°Âºè, ÂåÖÊï∏Èáè: ${audioPackets.length}, JSON Â§ßÂ∞è: ${jsonBlob.size} bytes`);
          
          // Áµ±Ë®àÂåÖÂ§ßÂ∞èÂàÜ‰Ωà
          const sizes = audioPackets.map(p => p.length);
          const minSize = Math.min(...sizes);
          const maxSize = Math.max(...sizes);
          const avgSize = Math.round(sizes.reduce((a, b) => a + b, 0) / sizes.length);
          console.log(`üìä ÂåÖÂ§ßÂ∞èÂàÜ‰Ωà: ÊúÄÂ∞è=${minSize}b, ÊúÄÂ§ß=${maxSize}b, Âπ≥Âùá=${avgSize}b`);
        } else {
          console.warn('‚ö†Ô∏è WebCodecs ÈåÑÈü≥Ê≤íÊúâÊî∂ÈõÜÂà∞Áç®Á´ãÂåÖ');
          setError('ÈåÑÈü≥Â§±ÊïóÔºöÊ≤íÊúâÊî∂ÈõÜÂà∞Èü≥È†ªÂåÖÊï∏Êìö');
        }
        
      } catch (error) {
        console.error('üö® WebCodecs ÂÅúÊ≠¢ÈåÑÈü≥ÊôÇÂá∫ÈåØ:', error);
        setError('ÂÅúÊ≠¢ÈåÑÈü≥ÊôÇÁôºÁîüÈåØË™§');
      }
      
    } else if (mediaRecorder && mediaRecorder.state === 'recording') {
      console.log('üõë ÂÅúÊ≠¢ MediaRecorder ÈåÑÈü≥');
      mediaRecorder.stop();
    }
    
    setIsRecording(false);
    
    // Ê∏ÖÁêÜË®àÊôÇÂô®
    if (recordingInterval) {
      clearInterval(recordingInterval);
      recordingInterval = null;
    }
  };

  const uploadAndProcess = async () => {
    const blob = audioBlob();
    if (!blob) {
      setError('Ê≤íÊúâÈü≥È†ªÊï∏ÊìöÂèØ‰∏äÂÇ≥');
      return;
    }
    
    setIsUploading(true);
    setError(null);
    
    try {
      const formData = new FormData();
      const mimeType = blob.type;
      const browser = browserInfo();
      
      // üöÄ Êô∫ËÉΩÁ´ØÈªûÈÅ∏Êìá - WebCodecs vs MediaRecorder
      let endpoint: string;
      let filename: string;
      
      if (mimeType === 'application/json' && browser?.recordingMethod === 'webcodecs') {
        // üöÄ WebCodecs Áç®Á´ãÂåÖÊ®°Âºè - ‰øÆÂæ©ÁâàÂØ¶Áèæ
        endpoint = '/upload';
        filename = 'webcodecs-packets.json';
        
        // ‰∏äÂÇ≥ JSON Ê†ºÂºèÁöÑÁç®Á´ãÂåÖÊï∏Êìö
        formData.append('audio_packets', blob, filename);
        
        console.log(`üöÄ WebCodecs Áç®Á´ãÂåÖ‰∏äÂÇ≥ - Ê™îÊ°à: ${filename}, MIME: ${mimeType}, Â§ßÂ∞è: ${blob.size} bytes`);
        console.log('üéØ ‰ΩøÁî®Áµ±‰∏ÄÁ´ØÈªûÔºåJSON Ê†ºÂºèËá™ÂãïÊ™¢Ê∏¨');
        
        const response = await fetch(endpoint, {
          method: 'POST',
          body: formData,
        });
        
        if (!response.ok) {
          const errorData: ErrorResponse = await response.json();
          throw new Error(errorData.error || `HTTP ${response.status}`);
        }
        
        const data: TranscriptResult = await response.json();
        setResult(data);
        setAudioBlob(null);
        
        console.log('‚úÖ WebCodecs Áç®Á´ãÂåÖ‰∏äÂÇ≥ÊàêÂäü');
        return;
      } else {
        // MediaRecorder ÂÇ≥Áµ±Ê†ºÂºè - Áµ±‰∏Ä‰ΩøÁî®Ê®ôÊ∫ñÁ´ØÈªû
        endpoint = '/upload';
        
        // Ê•≠ÁïåÈ†òÂÖàÔºöÊô∫ËÉΩÊ™îÂêçÁîüÊàê
        filename = 'recording';
        if (mimeType.includes('webm')) filename += '.webm';
        else if (mimeType.includes('ogg')) filename += '.ogg';
        else if (mimeType.includes('mp4')) filename += '.mp4';
        else if (mimeType.includes('wav')) filename += '.wav';
        else filename += browser?.ext || '.webm';
        
        console.log(`üìº MediaRecorder ‰∏äÂÇ≥ - Ê™îÊ°à: ${filename}, MIME: ${mimeType}, ÁÄèË¶ΩÂô®: ${browser?.name}`);
        console.log('üéØ ‰ΩøÁî®Áµ±‰∏ÄÁ´ØÈªûÔºå‰∫åÈÄ≤Âà∂Ê†ºÂºèËá™ÂãïÊ™¢Ê∏¨');
        
        // Â∞çÊñº‰∫åÈÄ≤Âà∂Ê†ºÂºèÔºå‰ΩøÁî®Ê®ôÊ∫ñÁöÑ audio Ê¨Ñ‰ΩçÂêç
        formData.append('audio', blob, filename);
      }
      
      // ÁôºÈÄÅÂà∞Â∞çÊáâÁöÑÂæåÁ´ØÁ´ØÈªû
      const response = await fetch(endpoint, {
        method: 'POST',
        body: formData,
      });
      
      if (!response.ok) {
        // WebCodecs Áµ±‰∏ÄÁ´ØÈªûËôïÁêÜÊâÄÊúâÊ†ºÂºèÔºåÁÑ°ÈúÄÈôçÁ¥ö
        
        const errorData: ErrorResponse = await response.json();
        throw new Error(errorData.error || `HTTP ${response.status}`);
      }
      
      const data: TranscriptResult = await response.json();
      setResult(data);
      setAudioBlob(null); // Clear the audio blob after successful upload
      
      console.log(`‚úÖ ‰∏äÂÇ≥ÊàêÂäü`);
      
    } catch (err) {
      console.error('Upload failed:', err);
      setError(err instanceof Error ? err.message : '‰∏äÂÇ≥Â§±ÊïóÔºåË´ãÈáçË©¶');
    } finally {
      setIsUploading(false);
    }
  };

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  const clearResults = () => {
    setResult(null);
    setError(null);
    setAudioBlob(null);
    setRecordingTime(0);
  };

  return (
    <div class="container">
      <div class="card">
        <h1 style="text-align: center; color: #1f2937; margin-bottom: 16px;">
          üéôÔ∏è Care Voice AI Ë™ûÈü≥ËΩâÈåÑÁ≥ªÁµ±
        </h1>
        
        {/* Á≥ªÁµ±ÁãÄÊÖãÈ°ØÁ§∫ - Ê•≠ÁïåÈ†òÂÖà */}
        <div style="text-align: center; margin-bottom: 24px; padding: 12px; background: #f9fafb; border-radius: 8px;">
          <Show when={browserInfo()}>
            <div style="font-size: 14px; color: #6b7280; margin-bottom: 8px;">
              üåê ÁÄèË¶ΩÂô®: <strong>{browserInfo()?.name}</strong> | 
              üéµ Ê†ºÂºè: <strong>{browserInfo()?.mimeType}</strong> |
              {browserInfo()?.isSupported ? 
                <span style="color: #059669;"> ‚úÖ ÂÆåÂÖ®ÊîØÊè¥</span> : 
                <span style="color: #dc2626;"> ‚ö†Ô∏è ÈÉ®ÂàÜÊîØÊè¥</span>
              }
            </div>
            <div style="font-size: 13px; color: #4b5563; margin-bottom: 8px;">
              üöÄ ÈåÑÈü≥ÊäÄË°ì: <strong>{browserInfo()?.recordingMethod === 'webcodecs' ? 'WebCodecs (Á°¨È´îÂä†ÈÄü)' : 'MediaRecorder (Áõ∏ÂÆπÊ®°Âºè)'}</strong> |
              {browserInfo()?.webCodecsSupported ? 
                <span style="color: #059669;"> ‚úÖ 2025Âπ¥Ê•≠ÁïåÈ†òÂÖà</span> : 
                <span style="color: #f59e0b;"> ‚ö†Ô∏è ÂÇ≥Áµ±ÊäÄË°ì</span>
              }
            </div>
          </Show>
          
          <Show when={healthStatus()}>
            <div style={`font-size: 14px; margin-bottom: 4px; color: ${isHealthy() ? '#059669' : '#dc2626'};`}>
              {isHealthy() ? 'üü¢' : 'üî¥'} ÊúçÂãôÁãÄÊÖã: <strong>{healthStatus()?.status}</strong>
            </div>
          </Show>
          
          <button 
            onClick={performHealthCheck} 
            style="font-size: 12px; padding: 4px 8px; background: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer;"
          >
            üîÑ ÈáçÊñ∞Ê™¢Êü•
          </button>
        </div>
        
        {/* ÈåÑÈü≥ÊéßÂà∂ - Ê•≠ÁïåÈ†òÂÖà‰ªãÈù¢ */}
        <div style="text-align: center; margin-bottom: 24px;">
          <Show when={!isRecording() && !audioBlob()}>
            <button 
              onClick={startRecording} 
              disabled={isUploading() || !isHealthy()}
              style={`padding: 12px 24px; font-size: 16px; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s; ${
                !isHealthy() ? 'background: #9ca3af; color: white;' : 'background: #3b82f6; color: white;'
              }`}
            >
              üé§ ÈñãÂßãÈ´òÂìÅË≥™ÈåÑÈü≥
            </button>
            {!isHealthy() && (
              <div style="font-size: 12px; color: #dc2626; margin-top: 8px;">
                ‚ö†Ô∏è ÊúçÂãôÊú™Â∞±Á∑íÔºåË´ãÊ™¢Êü•ÈÄ£Êé•
              </div>
            )}
          </Show>
          
          <Show when={isRecording()}>
            <div style="margin-bottom: 16px; padding: 16px; background: #fee2e2; border-radius: 8px;">
              <div style="font-size: 24px; font-weight: bold; color: #dc2626; margin-bottom: 8px; animation: pulse 1s infinite;">
                üî¥ Ê≠£Âú®ÈåÑÈü≥...
              </div>
              <div style="font-size: 18px; color: #6b7280; margin-bottom: 8px;">
                ‚è±Ô∏è {formatTime(recordingTime())}
              </div>
              <div style="font-size: 12px; color: #6b7280;">
                üéµ Ê†ºÂºè: {browserInfo()?.mimeType} | üåê ÁÄèË¶ΩÂô®: {browserInfo()?.name}
              </div>
            </div>
            <button 
              onClick={stopRecording} 
              style="padding: 12px 24px; font-size: 16px; background: #dc2626; color: white; border: none; border-radius: 8px; cursor: pointer; animation: pulse 1s infinite;"
            >
              ‚èπÔ∏è ÂÅúÊ≠¢ÈåÑÈü≥
            </button>
          </Show>
          
          <Show when={audioBlob() && !isUploading()}>
            <div style="margin-bottom: 16px; padding: 16px; background: #d1fae5; border-radius: 8px;">
              <div style="color: #059669; font-weight: bold; margin-bottom: 8px;">
                ‚úÖ ÈåÑÈü≥ÂÆåÊàêÔºÅ({formatTime(recordingTime())})
              </div>
              <div style="font-size: 12px; color: #6b7280;">
                üìÅ Ê™îÊ°àÂ§ßÂ∞è: {Math.round((audioBlob()?.size || 0) / 1024)} KB | 
                üéµ Ê†ºÂºè: {audioBlob()?.type === 'application/json' ? 'WebCodecs Áç®Á´ãÂåÖ' : audioBlob()?.type} | 
                üåê ÁÄèË¶ΩÂô®: {browserInfo()?.name}
              </div>
            </div>
            <button 
              onClick={uploadAndProcess} 
              style="padding: 12px 24px; font-size: 16px; background: #059669; color: white; border: none; border-radius: 8px; cursor: pointer; margin-right: 8px;"
            >
              üöÄ AI ËΩâÈåÑËôïÁêÜ
            </button>
            <button 
              onClick={clearResults} 
              style="padding: 12px 24px; font-size: 16px; background: #6b7280; color: white; border: none; border-radius: 8px; cursor: pointer;"
            >
              üîÑ ÈáçÊñ∞ÈåÑÈü≥
            </button>
          </Show>
        </div>
        
        {/* AI ËôïÁêÜÁãÄÊÖã - Ê•≠ÁïåÈ†òÂÖàË¶ñË¶∫Âåñ */}
        <Show when={isUploading()}>
          <div style="padding: 20px; background: #dbeafe; border-radius: 8px; text-align: center; margin: 16px 0;">
            <div style="font-size: 20px; margin-bottom: 12px; animation: pulse 1s infinite;">ü§ñ AI ËôïÁêÜ‰∏≠...</div>
            <div style="font-size: 14px; color: #1e40af; margin-bottom: 8px;">Ê≠£Âú®‰ΩøÁî® Whisper AI ËΩâÈåÑÈü≥È†ª‰∏¶ÁîüÊàêÊëòË¶Å</div>
            <div style="font-size: 12px; color: #6b7280;">
              üéµ Èü≥È†ªÊ†ºÂºè: {audioBlob()?.type === 'application/json' ? 'WebCodecs Áç®Á´ãÂåÖ' : audioBlob()?.type} | üìÅ Â§ßÂ∞è: {Math.round((audioBlob()?.size || 0) / 1024)} KB
            </div>
            <div style="width: 100%; height: 4px; background: #e5e7eb; border-radius: 2px; overflow: hidden; margin-top: 12px;">
              <div style="height: 100%; background: #3b82f6; width: 100%; animation: progress 2s linear infinite;"></div>
            </div>
          </div>
        </Show>
        
        {/* ÈåØË™§È°ØÁ§∫ - Ê•≠ÁïåÈ†òÂÖàÈåØË™§ËôïÁêÜ */}
        <Show when={error()}>
          <div style="padding: 16px; background: #fee2e2; border: 1px solid #fecaca; border-radius: 8px; margin: 16px 0;">
            <div style="font-weight: bold; margin-bottom: 8px; color: #dc2626;">‚ùå Á≥ªÁµ±ÈåØË™§</div>
            <div style="color: #dc2626; margin-bottom: 8px;">{error()}</div>
            <div style="font-size: 12px; color: #6b7280;">üí° Âª∫Ë≠∞: Ê™¢Êü•È∫•ÂÖãÈ¢®Ê¨äÈôêÂíåÁ∂≤Ë∑ØÈÄ£Êé•</div>
          </div>
        </Show>
      </div>
      
      {/* ÁµêÊûúÈ°ØÁ§∫ - Ê•≠ÁïåÈ†òÂÖàÁµêÊûúÂ±ïÁ§∫ */}
      <Show when={result()}>
        <div style="background: white; border-radius: 12px; padding: 24px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); margin-bottom: 24px;">
          <h2 style="color: #1f2937; margin-bottom: 16px; display: flex; align-items: center;">
            üìù ÂÆåÊï¥ÈÄêÂ≠óÁ®ø
            <span style="font-size: 12px; background: #d1fae5; color: #059669; padding: 4px 8px; border-radius: 4px; margin-left: 12px;">AI ËΩâÈåÑÂÆåÊàê</span>
          </h2>
          <div style="background: #f9fafb; padding: 16px; border-radius: 8px; line-height: 1.6; white-space: pre-wrap;">
            {result()?.full_transcript || 'Êö´ÁÑ°ËΩâÈåÑÁµêÊûú'}
          </div>
        </div>
        
        <div style="background: white; border-radius: 12px; padding: 24px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); margin-bottom: 24px;">
          <h2 style="color: #1f2937; margin-bottom: 16px; display: flex; align-items: center;">
            üéØ ÈóúÊá∑ÈáçÈªûÊëòË¶Å
            <span style="font-size: 12px; background: #dbeafe; color: #1e40af; padding: 4px 8px; border-radius: 4px; margin-left: 12px;">AI ÂàÜÊûêÊëòË¶Å</span>
          </h2>
          <div style="background: #f0f9ff; padding: 16px; border-radius: 8px; line-height: 1.6; white-space: pre-wrap;">
            {result()?.summary || 'Êö´ÁÑ°ÊëòË¶Å'}
          </div>
          
          <div style="text-align: center; margin-top: 24px;">
            <button 
              onClick={clearResults} 
              style="padding: 12px 24px; font-size: 16px; background: #059669; color: white; border: none; border-radius: 8px; cursor: pointer;"
            >
              üîÑ ÈñãÂßãÊñ∞ÁöÑÈåÑÈü≥
            </button>
          </div>
        </div>
      </Show>
    </div>
  );
}

export default App;